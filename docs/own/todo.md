# Todo

v0.1, goal: end of january 2021 (edit may 2021: lmao) 

urgent, bugs:
- [ ] Figure out how to correctly handle the maps in Device when using 
	  wrapping. Many ugly situations atm, see e.g. (important!) the
	  terrible hack in ~CommandPool and ~DescriptorPool
- [ ] (important) the way we copy/modify descriptor set states might have
      a data race at the moment. When copying, we might try to increase
	  the reference count of an already destroyed State object (when it is
	  currently being replaced?)
- [ ] (important) the way we currently copy vectors of IntrusivePtr handles
      outside the lock (e.g. in Gui) to make they don't get destroyed inside
	  isn't threadsafe...

matching:
- [ ] implement 'match' for missing commands
- [ ] fix command matching for sync/bind commands
	- [ ] bind: match via next draw/dispatch that uses this bind
	- [ ] sync: match previous and next draw/dispatch and try to find
	      matching sync in between? or something like that
- [ ] figure out how to correctly match swapchain.frameSubmissions to the
	  commandHook state. See TODO in cb.cpp `dlg_assert(found)`

command group rework:
- [ ] remove CommandGroups? Just rely on command matching instead?
      figure out how to properly do matching across command buffer
	  boundaries; taking the context - the position inside a frame - into account
- [ ] currently command groups *interfer* with our new, improved command matching
      since it may not recognize two records as being in the same group
	  when they should be (and we would find a perfect command match).
	  Another point for removing them in their current form; as a requirement
	  for command matching
- [ ] implement LCS and better general strategy when in swapchain mode for

descriptor indexing extension:
- [ ] make sure we fulfill multithreading requirements for
      VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT and friends
- [ ] fix handling of update_unused_while_pending descriptors, see ds.cpp
      also consider partially_bound flag
- [ ] (for later) investigate whether our current approach really
      works for descriptor sets with many thousand bindings

vertex viewer/xfb:
- [ ] really attempt to display non-float formats in 3D vertex viewer?
- [ ] fix 3D vertex viewer for 2D position data (needs separate shader I guess)
- [ ] support drawIndirectCount in vertex viewer
	- [ ] #43, probably for later: also support just showing a single draw command
		  (see the other todo - #42)
- [ ] vertex viewer improvements
	- [ ] automatically compute bounding box of data and center camera
	- [ ] allow showing active frustum
- [ ] xfb: support custom outputs, not just the Position Builtin
	- [ ] xfb: check whether format is supported
- [ ] better tabular display of data; also show indices

docs
- [ ] proper shipping and installing
	- [x] make the json file a config file, generated by meson
	- [ ] write wiki post on how to build/install/use it
	- [ ] fix for api: should probably load *real* name of library (generated
	      via meson), not some guesswork.
	      Important on windows, to support all compilers.
		  See TODO on lib name there
- [ ] write small wiki documentation post on how to use API
	- [ ] could explain why it's needed in the first place. Maybe someone
	      comes up with a clever idea for the hooked-input-feedback problem?
	- [x] write something on instance extensions for compute-only applications
	      see: https://github.com/KhronosGroup/Vulkan-Loader/issues/51
		  {see docs/compute-only.md}

window/overlay
- [ ] improve windows overlay hooking. Experiment with mouse hooks blocking
      input.
	- [ ] implement further messages, keyboard, mouse wheel
	- [ ] clean the implementation up
	- [ ] when not showing own cursor, just use GetCursorPos over
	      raw input. Causes problems at the moment
- [x] rework dev/gui so that there is never more than one gui. Supporting
      multiple guis at the same time is not worth the trouble (think
	  about command buffer hooking from multiple cb viewers...)
	- [ ] what to do when window *and* overlay is created? or multiple overlays?
		  Should probably close the previous one (move gui object)
		  See todo in Gui::init. Make sure there never is more than one
- [ ] improve window creation: try to match up used swa backend with enabled
	  vulkan extensions. Could extend swa for it, if useful
	  (e.g. swa_display_create_for_vk_extensions)
	- [ ] possibly fall back to xlib surface creation in swa
	- [ ] at least make sure it does not crash for features we don't
	      implement yet (such as sparse binding)
		   (could for instance test what happens when memory field of a buffer/image
		   is not set).

performance/profiling:
- [ ] identified bottleneck (e.g. with dota): the device mutex for DescriptorSetState.
      Should be possible to give each DescriptorSetState its own mutex.
	  Hm, might still be a problem that we update so many links between
	  resources (ds <-> cb and ds <-> view).
	  Could still try to use a linked grid for those links, could possibly
	  even make that completely lockfree.
	  Maybe we can even get rid of ds <-> cb links? That would help.
	  - [ ] ideally, we would have no (non-local) locks during descriptor
	        set updating.
- [ ] {high prio} also don't always copy DescriptorSetState on submission.
      Leads to lot of DescriptorSetState copies, destructors.
	  We only need to do it when currently in swapchain mode *and* inside
	  the cb tab. (maybe we can even get around always doing it in that
	  case but that's not too important).
	- [ ] ideally, we would have *no* locks during command recording at all
- [ ] {high prio} most of the notes in CommandHook::hook are highly relevant.
      Especially handling of hook state overflow. Happens quickly when switching
	  out of command viewer tab. We shouldn't do any hooking when we
	  are not currently in that tab.
- [ ] holding the device mutex while submitting is really bad, see queue.cpp.
      We only need it for gui sync I think, we might be able to use
	  a separate gui/sync mutex for that. Basically a mutex that (when locked)
	  makes sure our tracked state (e.g. dev.pending) really includes everything
	  that has been submitted so far. That mutex would have to be
	  locked before locking the device mutex, never the other way around.


object wrapping:
- [ ] {high prio} the many shared locks when recording a cb can be harmful as well.
      We could get around this when wrapping handles, should probably
	  look into that eventually (maybe allow to switch dynamically at
	  runtime since wrapping makes supporting new extensions out of the
	  box highly unlikely so users could fall back to hash tables at
	  the cost of some performance).
- [ ] (low prio) only use the hash maps in Device when we are not using object 
      wrapping. Otherwise a linked list is enough/better.
	  Could always use the linked list and the hash maps just optionally

gui stuff
- [ ] resource viewer: we don't know which handle is currently selected
      (in the window on the left), can get confusing when they don't have names.
	  Should probably be an ImGui::Selectable (that stays selected) instead
	  of a button
- [ ] resource viewer: basic filtering by properties, e.g. allow to just
      show all images with 'width > 1920 && layers > 3' or something.
	  Could start with images for now and add for other handles as needed.
	  Definitely useful for images, when exploring the resource space
- [ ] cb/command viewer: when viewing a batch from a swapchain,
      show the semaphores/fences with from a vkQueueSubmit.
	  When selecting the vkQueueSubmit just show an overview.
- [ ] figure out general approach to fix flickering data, especially
      in command viewer (but also e.g. on image hover in resource viewer)
- [ ] Add more useful overview. 
	- [x] Maybe directly link to last submitted command buffers?
	      {this is kinda shitty though, need the concept of command buffer groups
		   to make this beautiful}
	- [x] show graph of frame timings (see first sketch swapchain header)
	- [x] show enabled extensions
	- [ ] show enabled features
	- [ ] only show application info if filled out by app. collapse by default?
- [ ] imgui styling. It's really not beautiful at the moment, compare with
      other imgui applications
	- [ ] use custom font
	- [ ] also use icons where useful (via icon font, like e.g. tracy does)
	- [ ] some of the high-information widgets (barrier command, rp, pipe viewers)
	      are really overwhelming and hard to read at the moment.
		  Can be improved to grasp information for intuitively
	- [ ] add tooltips where it makes sense
	- [ ] go at least a bit away from the default imgui style
	      The grey is hella ugly, make black instead.
		  Use custom accent color. Configurable?
	- [ ] Figure out transparency. Make it a setting?
	- [ ] see imgui style examples in imgui releases
	- [ ] lots of places where we should replace column usage with tables
	- [ ] fix stupid looking duplicate header-seperator for commands in 
	      command viewer (command viewer header UI is a mess anyways)

other
- [ ] CommandMemBlock alignment handling might currently be wrong since
      we don't take the alignment of the beginning of the mem block into account,
	  might be less than __STDCPP_DEFAULT_NEW_ALIGNMENT__ due to obj size.
	  Handle it as we do in ThreadMemBlock
- [ ] correctly track stuff from push descriptors. Need to add handles and stuff,
      make sure destruction is tracked correctly. Also show in gui.
- [ ] with the ds changes, we don't correctly track commandRecord invalidation
      by destroyed handles anymore. But with e.g. update_unused_while_pending +
	  partially_bound, we can't track that anyways and must just assume
	  the records stays valid. 
	  We should just not expose any information about that in the gui or
	  state it's limitation (e.g. on hover).
	- [ ] if we absolutely need this information (e.g. if it's really useful
	      for some usecase) we could manually track it. Either by iterating
		  over all alive records on view/sampler/buffer destruction or
		  (e.g. triggered by explicit "query" button) by just checking
		  for all descriptors in a record whether it has views/sampler
		  with NULL handles (in not partially_bound descriptors I guess)
- [ ] clean up logging system, all that ugly setup stuff in layer.cpp
	- [ ] also: intercept debug callback? can currently cause problems
	      e.g. when the application controlled debug callback is called
		  from *our* internal thread (which it might not be prepared for).
		  In interception, could check whether it involves one of our
		  handles or is called from our window thread.
	- [ ] show failed asserts and potential errors in imgui UI?
	      probably best to do this in addition to command line
	- [ ] log assertions to debug console in visual studio
	      somehow signal they are coming from us though, use a VIL prefix or smth.
		  Stop allocating a console.
- [ ] IO rework
	- [x] start using src/gui/command.hpp
	- [ ] remaining IO viewer fixes:
		- [x] fix descriptor arrays
		- [ ] fix transfer buffer introspection
		- [ ] fix ClearAttachmentCmd handling, allow to copy/view any of the cleared attachments
		- [x] when viewing attachments, show framebuffer and image/imageView (see TODO in code)
		- [x] when viewing transfer img, show image refButton
		- [x] adapt ioImage_ to selected image (e.g. channels)
			- [ ] also fix logic for depthStencil images. Select depth by default.
				  (can be tested with doom)
	- [ ] support texel reading implementation for cb-viewed-images and clean
		  up color format presentation, support depth and packed formats.
		  See TODOs in gui.cpp:displayImage and util.cpp:ioFormat
	- [ ] fix `[cb.cpp:1056] assertion 'found' failed` for cmdUpdateBuffer,
	      i.e. support buffer IO viewing for transfer commands
- [ ] in CopiedImage::init: check for image usage support
	- [ ] generally: allow the image copy operation to fail.
- [ ] better pipeline/shader module display in resource viewer
	- [ ] especially inputs/outputs of vertex shaders (shows weird predefined spirv inputs/outputs)
	- [ ] maybe display each stage (the shader and associated information) as its own tab
- [ ] figure out "instance_extensions" in the layer json.
      Do we have to implement all functions? e.g. the CreateDebugUtilsMessengerEXT as well?
- [ ] more useful names for handles (e.g. some basic information for images)
	- [ ] also: atm we always prepend the resource type leading to something
	      like "Buffer terrainBuffer". Add a parameter to the function whether
		  this should be done, it some contexts (e.g. CmdCopyBuffer,
		  resource viewer only viewing buffers) its very redundant.
		  In most cases, it's redundant, only useful for some buttons (but
		  even then we likely should rather have `Image: |terrainHeightmap|`.
- [ ] should probably not be possible to ever unselect ParentCommands in
      cb viewer (CommandTypeFlags). Just always display them?
- [ ] improve handling of transparent images. Checkerboard background?
	- [x] when viewing image as grayscale they become transparent atm.
	      no idea why
	- [ ] also don't apply scale for alpha
- [ ] fix overlay for wayland. Use xdg popup
- [ ] make sure the environment variables for overlays/window creation work
      as specified in readme everywhere
- [ ] when viewing live command submissions, clicking on resource buttons
	  that change every frame/frequently (e.g. the backbuffer framebuffer)
	  does not work. Wanting to goto "just any of those" is a valid usecase IMO,
	  we could fix it by not imgui-pushing the resource ID before showing the button.
- [ ] stop this todo-for-v0.1-list from growing at some point.



Possibly for later, new features/ideas:
- [ ] could write patched shader spirv data into a pipeline cache I guess
      or maintain own shader cache directory with patched spirv
	  not sure if worth it at all though, the spirv patching is probably
	  not that expensive (and could even be further optimized, skip
	  the code sections).
- [ ] (low prio) our descriptor matching fails in some cases when handles are abused
	  as temporary, e.g. imageViews, samplers, bufferViews (ofc also for
	  stuff like images and buffers).
	  Probably a wontfix since applications
	  should fix their shit but in some cases this might not be too hard
	  to support properly with some additional tracking and there might
	  be valid usecases for using transient image views
- [ ] (low prio but highly interesting) optionally capture callstacks for each command
      immediately jumping to the point the command was recorded sounds
	  useful. Could build in support for vim and visual studio I guess.
	  See https://github.com/bombela/backward-cpp/blob/master/backward.hpp
- [ ] get it to run without significant (slight (like couple of percent) increase 
	  of frame timings even with layer in release mode is ok) overhead.
	  Just tests with the usual suspects of games
- [ ] make vertex viewer useful
	- [ ] allow to select vertices, render them as points in the viewport
	- [ ] allow to visualize primitives
	- [ ] allow to visualize non-builtin attributes somewhow
	      maybe also allow to manually pick an attribute to use as position
		  for the input?
- [ ] alternative view of DeviceMemory showing a better visualization of
      the resources placed in it (and the empty space)
- [ ] support debug utils labels across command buffer boundaries
	  we already have the information of popped and pushed lables per record
      NOTE: this isn't 100% correct at the moment though, e.g. when we end
	  a debug label manually to fix the hierachy, it's only ended to the "ignoreEnd"
	  counter but if that end is never called (to be ignored) the label would
	  effectively be pushed onto the queue stack which we currently don't
	  store anywhere. Not sure how to correctly do this though atm, depends
	  on how we use it later on (since the label isn't effectively on the
	  queue stack for our fixed hierachy...)
- [ ] cmdDrawIndirectCount: allow to view state (especially attachments
      but i guess could be useful for ds state as well) before/after each
	  individual draw command. Same for cmdDrawIndirect with multiple
	  draw counts. Could likely use the same mechanism to do the same for
	  instances - #42
	  See - #43
- [ ] functions that allocate CommandRecord-memory should not take
      a CommandBuffer& as first argument but rather something like
	  CommandRecordAllocator (or just CommandRecord), for clarity.
- [ ] limit device mutex lock by ui/overlay/window as much as possible.
    - [ ] We might have to manually throttle frame rate for window
	- [ ] add tracy (or something like it) to the layer (in debug mode or via 
	      meson_options var) so we can properly profile the bottlenecks and
		  problems
- [ ] improve frame graph layout in overview. Looks not nice atm
	- [ ] maybe try out implot lib
	- [ ] instead of limiting by number of frames maybe limit by time?
		  the 1000 last timings (as it is right now) is bad, not enough for high-fps applications
- [ ] implement clipboard, cursor style and other feature support for imgui
	- [ ] in window.cpp, for our external debug window
	- [ ] where useful (and really needed) incorporate it into the public API
- [ ] (low, later) add own normals to vertex viewer (either somehow on-the-fly on gpu or
      pre-calculate them on cpu) and add basic shading.
	  maybe we can reuse existing normals in some cases but i doubt it,
	  no idea for good heuristics
- [ ] when selecting a draw call, allow to color it in final render
	- [ ] would require us to modify shader/pipeline. lots of work
- [ ] when we select a resource of type X should we set the current filter to X
      in the resource gui? Can be somewhat confusing at the moment
- [ ] the gui code is currently rather messy. Think of a general concept
      on how to handle tabs, image draws and custom pipelines/draws inside imgui
- [ ] reading 64-bit int formats might have precision problems, see the format
      io in util.cpp
- [ ] Implement missing resource overview UIs
	- [ ] sync primitives (-> submission rework & display, after v0.1)
- [ ] show histogram to image in ui. Generate histogram together with min/max
      values to allow auto-min-max as in renderdoc
	- [ ] Using the histogram, we could add something even better, adjusting
	      tonemapping/gamma/min-max to histogram instead just min-max
- [ ] displaying high-res images in small viewer gives bad artefacts
      since we don't use mips. Could generate mips on our own (this requires
	  just copying the currently vieweed mip and then generating our own mips)
- [ ] attempt to retain previous selection in io viewer when selecting
	  new command
- [ ] in vkCreateInstance/vkCreateDevice, we could fail if an extension we don't support
      is being enabled. I remember renderdoc doing this, sounds like a good idea.
	- [ ] or an unexpectly high api version
		  (allow to disable that behavior via env variable tho, layer might work
		   with it)
	- [ ] overwrite pre-instance functions vkEnumerateInstanceExtensionProperties?
	      then also use the vkGetPhysicalDeviceProcAddr from the loader to
		  overwrite extension enumeration for the device.
		  And filter the supported extensions by the ones that we also support.
		  Evaluate whether this is right approach though. Renderdoc does it like
		  this. Alternatvely, we could simply fail on device/instance creation
		  as mentioned above (probably want to do both approaches, both disableable 
		  (just found a new favorite word!) via env variable
- [ ] add feature to see all commands that use a certain handle.
      we already have the references, just need to add it to command viewer.
	  Just add a new command viewer mode that allows to cycle through them.
	- [ ] make sure to select (and scroll towards) the commands when selecting
	      them. Not exactly sure how to implement but that command should
		  even be shown in command list when its type is hidden (maybe
		  make it a bit transparent, "ghost-command")
- [ ] in some places we likely want to forward pNext chains by default, even
      if we don't know them. E.g. QueuePresent, render pass splitting?
	  Whatever gives the highest chance of success for unknown extensions.
	  (Could even try to toggle it via runtime option)
- [ ] full support CmdDrawIndirectCount in gui (most stuff not implemented atm in CommandHook)
	  {probably not for v0.1} 
- [ ] improve buffer viewer {postponed to after v0.1}
	- [ ] NOTE: evaluate whether static buffer viewer makes much sense.
	      Maybe it's not too useful at the moment.
	- [x] static buffer viewer currently broken, see resources.cpp recordPreRender
	      for old code (that was terrible, we would have to rework it to
		  chain readbacks to a future frame, when a previous draw is finished)
	- [ ] ability to infer layouts (simply use the last known one, link to last usage in cb) from
		- [ ] uniform and storage buffers (using spirv_inspect)
		- [ ] vertex buffer (using the pipeline layout)
		- [ ] index buffer
		- [ ] texel data from a buffer/image copy
	- [ ] ability to directly jump to it - in the contextually inferred layout - from a command?
	      (might be confusing, content might have changed since then)
	- [ ] move to own tab/panel? needed in multiple cases
- [ ] improve image viewer
	- [ ] move to own tab/panel? needed in multiple cases
	      {nah, viewing it inline is better for now}
- [ ] attempt to minimize level depth in cb viewer
	- [ ] when a parent has only one child, combine them in some cases?
	      mainly for Labels, they are currently not too helpful as they
		  make the hierachy just deeper...
	- [ ] allow per-app shortcuts to specific commands?
- [ ] look into imgui shortcuts to allow quick interaction.
      vim-like!
- [ ] we might be able to improve the accuracy of the queried timings (in hooked cbs)
      with inserted pipeline barriers. That will cause certain stages/commands
	  to stall so we can measure the per-stage time in a more isolated environment
- [ ] transfer command IO inspector for buffers
- [ ] transfer commands IO insepctor for ClearAttachmentCmd: allow to select
      the attachment to be shown in IO list and then copy that in commandHook
- [ ] support multiple subresources for transfer commands, images
	- [ ] pain in the ass regarding layout transitions as the range of
	      subresources does not have to be continuous (and we can't assume
		  all of them to be in same layout)
- [ ] important optimization, low hanging fruit:
      CopiedImage: don't ever use concurrent sharing mode.
	  We can explicitly transition the image when first copying it.
- [ ] we currently copy more levels/layers in commandHook than are shown
      in i/o inspector. Could just copy the currently shown subresource.
- [ ] write tests for some common functionality
	- [ ] format reading/writing; conversion
- [ ] clean up/unify usage of struct/class
	  struct for POD (with no public/private classifiers and member functions),
	  class otherwise I guess
- [ ] move external source into extra folder
- [ ] we should likely switch to spirv-cross instead of spirv-reflect
	- [ ] we will probably need some its functionality later on anyways
	- [ ] already hit some hard limitations of spirv-cross that would require
	      a lot of changes
- [ ] support timeline semaphores (submission rework/display)
- [ ] support for the spirv primites in block variables that are still missing
 	  See https://github.com/KhronosGroup/SPIRV-Reflect/issues/110
	- [ ] runtime arrays (based on buffer range size)
	- [ ] spec constant arrays
- [ ] performance: when a resource is only read by us we don't have to make future
	  submissions that also only read it wait.
	- [ ] requires us to track (in CommandRecord::usedX i guess) whether
		  a resource might be written by cb
- [ ] support for multiple swapchains
	- [ ] in submission viewing, we assume there is just one atm
	- [ ] currently basically leaking memory (leaving all records alive)
	      when application has a swapchain it does not present to?
- [ ] Allow modifying resources (temporarily or permanently)
	- [ ] in command viewer or resource viewer
	- [ ] over such a mechanism we could implement a forced camera
- [ ] include vkpp enumString generator here?
      allows easier updates, maintaining
- [x] support for buffer views (and other handles) in UI
	- [ ] use buffer view information to infer layout in buffer viewer?
	- [ ] support buffer views in our texture viewer (i.e. show their content)
- [ ] experiment with transparent overlay windows in which we render the
      overlay, to not be dependent on application refresh rate.
- [ ] support compressed/block formats
- [ ] allow to view submissions to a queue
- [ ] implement at least extensions that record to command buffer to allow hooking when they are used
	- [x] push descriptors
	- [ ] device masks (core vulkan by now)
	- [ ] extended dynamic state
	- [ ] line rasterization
	- [ ] nv device diagnostic checkpoint
	- [ ] nv exclusive scissor
	- [ ] nv mesh shaders
	- [ ] amd buffer marker
	- [ ] intel performance metrics
	- [ ] ray tracing
	- [ ] nv shading rate image
	- [ ] ext sample locations
	- [ ] ext discard rectangles
	- [ ] nv viewport scaling
	- [ ] ext conditional rendering
	- [ ] transform feedback (?)
	- [x] implement khr_copy_commands2 extension
	- [ ] khr fragment shading rate
	- [ ] nv shading rate enums
- [ ] implement additional command buffer viewer mode: per-frame-commands
      basically shows all commands submitted to queue between two present calls.
	  similar to renderdoc
	- [ ] or just show the most important submission for now? (based on "main
	      submission" heuristics)
- [ ] use new imgui tables api where useful
- [ ] should support image-less framebuffer extension as soon as possible,
      might need a lot of changes
- [ ] add "save to ktx" feature on images? Personally, I'd consider this
      useful but this will likely scream LETS ABUSE PROPRIETARY IMAGES to some
	  evil creatures out there so not sure if this is a good idea.
	  Maybe just don't enable it in default build config?
	- [ ] pretty much same for writing out buffer contents to a file
	- [ ] could export full models from drawcalls via gltf
		  (without textures or at unassigned textures or maybe even
		   try to connect them to gltf properties via heuristics)
- [ ] support for compressed image formats
- [ ] optimize: suballocate and CopiedBuffer
- [ ] optimize: reuse CopiedImage and CopiedBuffer
- [ ] support multiple imgui themes via settings
- [ ] remove PageVector when not used anymore. Maybe move to docs or nodes
- [ ] in cb viewer: allow to set collapse mode, e.g. allow more linear layout?
      and other settings
- [ ] make gui more comfortable to use
	- [ ] add shortcuts for important features
	- [ ] investigate if we can make it vim-like navigatable keyboard-only
	- [ ] make "back" button work (and add one it gui itself?)
- [ ] investigate the vulkan layer providing the timeline semaphore feature.
      We could advise its usage when a native implementation is not available.
	  Eventually we could (either by requiring use of the layer when ext not
	  implemented by driver or by implementing it inside our layer) expect
	  timeline semaphores to be available, removing the legacy code path.
- [ ] fix warning 4458, see meson.build, we currently disable it.
- [ ] optimization: use custom memory management in QueueSubmit impl
	- [ ] investigate other potential bottleneck places where we
	      allocate a lot
- [ ] internal statistics tab
	- [ ] number of hooked command buffer records (alive records)
	- [ ] time spent in certain critical sections?
	- [ ] memory allocated in commandpools?
	- [ ] total number of handles or something, giving an estimate of memory consumption
- [ ] the way we currently split render passes does not work for resolve
	  attachments (except when they are in the last subpass) since
	  the resolve might be done multiple times, overwriting old results :(
	  In that case: either just don't allow command hooking (for now) or
	  just do the expensive solution: completely modify the render passes
	  and recreate all framebuffers and graphics pipelines ugh
- [ ] somehow display submissions and their dependencies as a general
      frame-graph like overview (could go down to renderpass-level, to
	  provide a full frame graph).
	- [ ] Maybe start with something that simply writes a dot file for a frame or two?
	      Getting this right interactively with imgui will be... hard
- [ ] command groups: come up with a concept to avoid glitchy updates
	  in viewer. Either just update every couple of seconds (lame!) or
	  display something special there.
- [ ] opt: even for command buffer recording we still allocate memory in a lot
	  of places (e.g. CommandBufferDesc::getAnnotate but also in Record/Desc itself).
	  Fix what is possible
- [ ] command groups: should probably also check commonly used handles to match them.
	  at least some handles (at least root resources like memory, samplers etc)
	  will always be in common. Command buffers that use almost entirely the
	  same buffers and images can be considered related
- [x] bump api version as far as possible when creating instance?
      not sure if anything could go wrong in practice
- [ ] register own debug messenger if possible?
- [ ] not sure if current cmdExecuteCommands implementation is the best.
      see comment there.
- [ ] for command descriptions, take pNext chains into account.
	  they are rarely changed just like that (neither is their order I guess)
- [ ] track push constant range pipe layouts; correctly invalidate & disturb
      also track which range is bound for which stage.
- [ ] can we support viewing multisample images?
      either sample them directly in shader (requires a whole lotta new 
	  shader permuatations, not sure if supported everywhere) or resolve
	  into temporary image first (lot of work as well)
- [ ] we might be able to not lock the device mutex for all the time we lock
      the ui (which can be a serious problem) by relying on weak/shared pointers
	  eveywhere (making concurrently happening resource destruction no problem) 
	  	- [ ] probably requires a lot of other reworks as well, e.g. for buffer readback
- [ ] better installing
	- [ ] simple wix windows installer, just needs to install prebuilt layer,
	  	   json file and add the registry file. Should probably also install
	       api header tho
		   (maybe for later, >0.1.0?)
	- [ ] write AUR package (maybe for later, >0.1.0?)
- [ ] add example images to docs
- [ ] in draw/dispatch commands: we might have to check that layout of bound
      descriptors matches layout of bound pipeline
- [ ] general buffer reading mechanism for UI. Implement e.g. to read
      indirect command from buffer and display in command UI
- [ ] allow to display stuff (e.g. images) over swapchain, fullscreen, not just in overlay
- [ ] memory budget overview
	- [ ] show how much memory was allocated overall, per-heap
	      make this visually appealing, easy-to-grasp. Maybe via pie-chart or something.
		  We can probably start using ImPlot.
		  Maybe allow to have a global pie chart (showing *all* memory) and
		  then per heap/per memory type flag (allowing us to easily visualize
		  e.g. the amount of on-device memory allocated/available).
	- [ ] Also allow to color memory depending on the type it is allocated for.
	- [ ] allow to visualize by allocation size, i.e. showing the big memory blockers
	      (but also allow showing smallest first, can be useful)
	- [ ] visualize totally available memory as well, we can get that from
	      memory properties
	- [ ] there are extensions for querying the real allocated/free memory
	      size. Use them!
- [ ] simulate device lost: Just make the layer return deviceLost from
      all (or a lot of) commands until the device is recreated.
	  Useful for testing!
- [ ] small buffer optimization for global hash tables (that are most
      commonly accessed). Maybe add extra fast path for single-device case?
	  (having something like Device* lastDevice in global scope, would
	  still need mutex but spare us hashing and lookup and extra cache miss)
- [ ] show histogram for query pool timings (for inserted ones, but could
      also do it for application query pool timings).
- [ ] add per-section and per-commandbuffer query pool timings
- [ ] add optional to just show timing per command (correctly show it per section)
      in command buffer command list.
	  Wouldn't even need to use the (error-prone) command buffer hooking
	  mechanism, could just insert it directly into the forwarded recording
	  commands.
- [ ] improve the case where multiple command buffers are pretty much the
      same and just vary for swapchain image id or something.
- [ ] directly show content for imageview? with correct format/mip/layer etc?
- [ ] (somewhat high prio tho) add support for waiting for command buffer
      recording to finish (with a timeout tho, in which case we simply display
	  that is currently being recorded (and that it takes long)), when viewing
	  it. Especially a big problem for display-window (compared to overlay)
	  when an application re-records in every frame.
	  	- [ ] could be done via conditional variable in command buffer
		      that is signaled on endCommandBuffer
- [ ] handle command-buffer re-recording as graceful as possible.
      	- [x] Try to match selected command in new state
		- [ ] give visual/explicit feedback about re-recording though.
		      maybe show time/frames since last re-record?
			  Show statistics, how often the cb is re-recorded?
- [ ] related to command buffer groups: simply view all commands pushed
      to a queue?
- [ ] way later: support for sparse binding
- [ ] we might be able (with checks everywhere and no assumptions at all, basically)
      to support cases where extensions we don't know about/support are used.
	  (e.g. image is created via a new extension, we don't hook that call,
	  image is then used somewhere). Evaluate if it is doable. If so, we should
	  really try. Even if we don't catch all cases it will make this a lot
	  easier to maintain (and make it seem less of a buggy mess to users)
- [ ] support vulkan 1.1 (non-crash)
	- [x] bindmemory2
	- [x] support descriptor set update templates
	- [x] support vkCmdDispatchBase
	- [ ] support device mask stuff (non-crash)
		- [ ] allow to hook command buffers containing it
		- [ ] layer might break with this though, not sure if we can support it easily
			  for real multi-gpu. Investigate (not supporting it for now is
			  okay but document why).
	- [ ] support everything in UI
		- [ ] add sampler ycbcr conversion tracking
- [ ] support vulkan 1.2 (non-crash)
	- [ ] support everything in UI
	- [x] CmdDrawIndirectCount
	- [x] CmdDrawIndexedIndirectCount
	- [x] other new creation and commands
- [ ] support as many KHR extensions as possible (non-crash)
	- [ ] support UI for them where not too much work
- [ ] support khr ray tracing extension
- [ ] support all other extensions (non-crash)
- [ ] interactive 3D cubemap viewer
- [ ] interactive 3D model viewer
- [x] insert command buffer timing queries
- [ ] per-drawcall image visualization using the inserted subpass + 
      input attachment shader copy idea, if possible
- [ ] event log showing all queue submits
	- [ ] optionally show resource creations/destructions there as well
- [ ] resource and queue freezing
	- [ ] something like "freeze on next frame/next submission"
- [x] track query pools
- [x] track buffer views
- [ ] better pipeline state overview of inputs, stages, outputs
	- [ ] maybe via a graph?
- [ ] we might be able to properly hook input (without needing the public api)
	  by using a (movable?) child window for our overlay instead of directly
	  presenting to the swapchain.
- [ ] when rendering in own window: continue to dispatch display while
      waiting for application fence. This allows to track really long
	  submissions (e.g. for compute) without losing responsiveness.
	  (Just show something like "image/buffer is in use in the ui")
	  -> sync rework/semaphore chaining, i guess (but note how it's **not**
		 solved with semaphore chaining alone!)
- [ ] all this dynamic_cast'ing on Command's isn't good. There is a limited
      number of commands (and we never absolutely need something like
	  dynamic_cast<DrawCmdBase*> i guess?) so we could enum it away.
	  But otoh dynamic_cast and hierachy is probably better for maintainability
- [ ] explore what random stuff we are able to do
	- [ ] Visualize models (drawcalls) on its own by inferring
	  	  position (and possibly other attribs; hard to infer though, could use heuristics
	  	  but should probably let user just flag them explicitly)
	- [ ] Infer projection and view matrix, allow to manipulate them.
	      We could add our entirely own camera to any game, allowing free movement
		  in the world (likely glitched due to culling and stuff but that's still interesting).
		  Hard to infer the correct matrix, might rely on manual user flagging.
	- [ ] Infer as much general information as possible. When annotations are
		  missing automatically annotate handles and the command buffer
		  as good as possible. We are likely able to detect depth-only (should probably
		  even be able to develop good heuristics to decide shadow vs preZ), gbuffer,
		  shading, post-processing passes. Might also be able to automatically infer
		  normal/diffuse/other pbr maps (harder though).
	- [ ] use heuristics to identify interesting constants in ubo/pcr/shader itself
		  (interesting as in: big effect on the output). Expose them as parameters
		  in the gui.
- [ ] include copy regions in argumentsDesc of transfer commands?
      would probably make sense but they should not be weighted too much
- [ ] (low prio, experiment) allow to visualize buffers as images where it makes sense 
	  (using a bufferView or buffer-to-image copy)
- [ ] (low prio) can we support android?
- [ ] (low prio, evaluate idea) allow to temporarily "freeze destruction", causing handles to be
      moved to per-handle, per-device "destroyedX" maps/vectors.
	  The vulkan handles probably need to be destroyed (keeping them alive
	  has other problems, e.g. giving memory back to pools, don't wanna
	  hook all that) but it might be useful to inspect command buffers without
	  handles being destroyed
- [ ] (low prio, non-problem) when using timeline semaphores, check for wrap-around?
      would be undefined behavior. But I can't imagine a case in which
	  we reuse a semaphore 2^64 times tbh. An application would have to
	  run millions of years with >1000 submissions per second.
	  Probably more error prone to check for this in the first place.
- [ ] (low prio), optimization: in `Draw`, we don't need presentSemaphore when
	  we have timeline semaphores, can simply use futureSemaphore for
	  present as well

old:
- [ ] optimization: we don't really need to always track refCbs and store
      the destroyed handles. Only do it for submissions viewed in gui?
	  Could just require commandRecords to be valid while selected and
	  then just handle the unsetting logic in CommandBufferGui::destroyed
	    Hm, on a second thought, this won't work so easily since we might
		select a new record that is already invalidated (useful in some
		cases I guess). Also, we want to support showing every command
		for a given handle at some point, where we need this tracking as well.
