#version 460

#extension GL_EXT_buffer_reference : require

layout(local_size_x = 64) in;

layout(buffer_reference, std430, buffer_reference_align = 2) buffer Indices {
	uint vals[];
};

layout(buffer_reference, std430, buffer_reference_align = 2) buffer Vertices {
	uint vals[];
};

layout(buffer_reference, std430, buffer_reference_align = 2) buffer Dst {
	uint vals[];
};

layout(push_constant) uniform PCR {
	Indices inds;
	Vertices verts;
	Dst dst;
	uint count;
	uint indexSize;
	uint vertSize; // byteSize / 4
	uint vertStride; // byteSize / 4
} pcr;

void main() {
	uint id = gl_GlobalInvocationID.x;
	if(id >= pcr.count) {
		return;
	}

	uint idx = id;

	if(pcr.indexSize == 2u) {
		idx = pcr.inds.vals[id / 2];

		// NOTE: we assume little endian here. Should probably just use
		// 16-bit ints in this case, devices that support raytracing
		// will likely also support 16-bit shader storage.
		if(id % 1 == 0u) {
			idx &= 0xFFFFu;
		} else {
			idx >>= 16u;
		}
	} else if(pcr.indexSize == 4u) {
		idx = pcr.inds.vals[id];
	}

	uint base = pcr.vertStride * idx;
	for(uint i = 0u; i < pcr.vertSize; ++i) {
		pcr.dst.vals[base + i] = pcr.verts.vals[base + i];
	}
}
